---
title: "GAMLSS modelling in mgcv and mgcViz"
date: '`r format(Sys.Date(), "%B %d %Y")`'
author: "Matteo Fasiolo"
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{gamlss}
    %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
library(knitr)
library(rgl)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center", tidy=FALSE)
knit_hooks$set(webgl = hook_webgl)
```

```{r setup1, include=FALSE}
library(RhpcBLASctl); blas_set_num_threads(1)
```

Body mass index modelling 
=======================

Simple data set on BMI vs age:
```{r gripss1, message = F}
library(testGam)
data(dbbmi)

plot(bmi ~ age, data = dbbmi)
```

Get subset to speed up computation:
```{r gripss1b, message = F}
set.seed(151)
dbbmi <- dbbmi[sample(1:nrow(dbbmi), 2000), ]
dbbmi <- dbbmi[order(dbbmi$age), ]
```
We fit a standard Gaussian GAM:
```{r gridss2, message = F}
library(mgcViz)
fit1 <- gamV(bmi ~ s(age, bs = "ad", k = 20), 
             data = dbbmi, 
             aViz = list(nsim = 50))
```
The mean bmi vs age looks right:
```{r gridss2_check, message = F}
check1D(fit1, "age") + l_gridCheck1D() 
```
Now we check the residuals standard deviation along `age`:
```{r gridss2_check_sd, message = F}
check1D(fit1, "age") + l_gridCheck1D( sd )
```
The variance is clearly increasing. We take this into account using a `shash` model
```{r gridss3, message = F}
fit2 <- gamV(list(bmi ~ s(age, bs = "ad", k = 20), # Location 
                      ~ s(age), # Scale
                      ~ 1,      # Skewness
                      ~ 1),     # Kurtosis
             data = dbbmi, 
             family = shash,
             aViz = list(nsim = 50))
```
and we repeat the check and check also for skewness
```{r gridss3_check_sd_2, message = F}
check1D(fit2, "age") + l_gridCheck1D( sd )

library(e1071)
check1D(fit2, "age") + l_gridCheck1D( skewness )
```
Model the skewness as well
```{r gridss6, message = F}
fit3 <- gamV(list(bmi ~ s(age, bs = "ad", k = 20), ~ s(age), ~ s(age), ~ 1),   
             data = dbbmi, 
             family = shash,
             aViz = list(nsim = 50))

check1D(fit3, "age") + l_gridCheck1D( skewness )
```

Plot effects:
```{r gridss7, message = F}
print(plot(fit3), pages = 1)
```

Plot quantiles:
```{r dbbmi13, message = F}
plot(bmi~age, data=dbbmi, col = "grey")
pr <- predict(fit3)
for(.q in c(0.01, 0.25, 0.5, 0.75, 0.99)){
  q_hat <- fit3$family$qf(.q, pr)
  lines(dbbmi$age, q_hat, col = 2)
}
```

Multivariate modelling of the GEFCom14 electricity demand data
=======================

Load data and have a look at it
```{r loadDat, fig.width = 7, fig.height = 5}
library(SCM)
library(mgcViz)

data(GEF14_d4)
head(GEF14_d4[ , c("year", "doy", "dow", "load_h17", "load24_h17", "temp_h17", 
                   "load_h20", "load24_h20", "temp_h20")])
```

Fit a bivariate Gaussian GAM:
```{r fit_gaus, message = F, fig.width = 8, fig.height = 5}
fit1 <- gam_scm(list(load_h17 ~ dow + s(doy, k = 15) + load24_h17 + s(temp_h17), 
                     load_h20 ~ dow + s(doy, k = 15) + load24_h20 + s(temp_h20)), 
                family = mvn_scm(d=2), # OR mgcv::mvn(d=2)
                data = GEF14_d4)
fit1 <- getViz(fit1, nsim = 25)
```

Plot the fitted effects:
```{r plot_g, fig.width = 7, fig.height = 5}
print(plot(fit1), pages = 1)
```

Get predicted mean vector and covariance matrix:
```{r plot_ga, fig.width = 7, fig.height = 5}
pred <- predict(fit1, type = "response")
head(pred)
```

Does the variance change with `doy`?
```{r plot_gaa, fig.width = 7, fig.height = 5}
check1D(fit1, "doy") + l_gridCheck1D(gridFun = function(.x){ 
  sd(.x[ , 1])
 }
)
```

Does the correlation change with `doy`?
```{r plot_ga2, fig.width = 7, fig.height = 5}
check1D(fit1, "doy") + l_gridCheck1D(gridFun = function(.x){ 
  cor(.x[ , 1], .x[ , 2])
 }
)
```

Model the covariance (it's MDC parametrisation) using `doy`: 
```{r plot_ga3, fig.width = 7, fig.height = 5}
fit2 <- gam_scm(list(load_h17 ~ dow + s(doy, k = 15) + load24_h17 + s(temp_h17), 
                     load_h20 ~ dow + s(doy, k = 15) + load24_h20 + s(temp_h20), 
                     Th_11 ~ s(doy), 
                     Th_22 ~ s(doy), 
                     Th_12 ~ s(doy)), 
                family = mvn_scm(d=2), data = GEF14_d4)
fit2 <- getViz(fit2, nsim = 25)
```

Repeat the checks:
```{r plot_ga4, fig.width = 7, fig.height = 5}
check1D(fit2, "doy") + l_gridCheck1D(gridFun = function(.x){ 
  sd(.x[ , 1])
 }
)

check1D(fit2, "doy") + l_gridCheck1D(gridFun = function(.x){ 
  cor(.x)[1, 2]
 }
)
```

Look at accumulated local effects (ALEs) of `doy` on load variance at 5pm:
```{r ALE0, fig.width = 7, fig.height = 5}
# NOTE: for ALEs you need install_github("mfasiolo/mgcViz")
plot(ALE(fit2, oind = 3, x = "doy", type = "response"))
```
and correlation:
```{r ALE1, fig.width = 7, fig.height = 5}
plot(ALE(fit2, oind = 5, x = "doy", type = "response"))
```

Look at predictions of bi-variate Gaussian:
```{r plot_ga6, fig.width = 7, fig.height = 5}
preds <- predict(fit2, type = "response")
head(preds)
```

```{r plot_ga0, dev='png', fig.width = 5, fig.height = 5, fig.show='hide'}
library(mvnfast)
ii <- 1
sig_1 <- sqrt(preds[ii, 3])
sig_2 <- sqrt(preds[ii, 4])
corr_12 <- preds[ii, 5]
x     <- seq(-2, 2, length.out = 100) * max(sqrt(preds[ , 3:4]))
y     <- seq(-2, 2, length.out = 100) * max(sqrt(preds[ , 3:4]))
mu    <- c(0, 0)
sigma <- matrix(c(sig_1^2, corr_12*sig_1*sig_2, corr_12*sig_1*sig_2, sig_2^2), nrow = 2)
f     <- function(x, y) dmvn(cbind(x, y), mu, sigma)
z     <- outer(x, y, f)

contour(x, y, z, main = paste0("Day of year = ", GEF14_d4$doy[ii]), 
        xlab = "Demand at 5pm", ylab = "Demand at 8pm")
ii <- ii + 10
```

![Bi-variate demand distribution (centered at zero)](`r knitr::fig_chunk('plot_ga0', 'png')`){width=60%}

Dynamic aggregation of experts for smart meter data forecasting
=======================

Load some packages and the data:
```{r fact1, fig.width = 6, fig.height = 6, message = F}
library(gamFactory)
library(mgcViz)
library(dplyr)
library(magrittr)

data("smart_dat")
head(round(smart_dat, 2))
```

Look at the data and divide into train/test:
```{r fact2, fig.width = 7, fig.height = 5}
train <- smart_dat[smart_dat$test == FALSE, ]
test <- smart_dat[smart_dat$test == TRUE, ]

plot(smart_dat$ldem, type = "l")
abline(v = nrow(train), lty = 2, col = 2, lwd = 2)
```

Look at experts fit on train set:
```{r fact2a, fig.width = 7, fig.height = 5}
plot(train$ldem[2500:6000], type = "l")
lines(train$mu_g[2500:6000], col = 4, lwd = 2)
lines(train$mu_l[2500:6000], col = 2, lwd = 2)
```

Fit stacking model to training set, weights depend on lagged MSEs:
```{r fact3, fig.width = 7, fig.height = 5}
library(gamFactory)
library(mgcViz)
stack <- gam(list(ldem ~ s(mse_g_48, k = 5) + s(mse_l_48, k = 5)), 
             family = fam_stackProb(cbind(train$lp_g, train$lp_l)), 
             data = train)
stack <- getViz(stack)
```

Plot effects:
```{r fact4, fig.width = 9, fig.height = 5}
print(plot(stack), pages = 1)
```

Predict weights on test set and get weighted predicted mean:
```{r fact5, fig.width = 7, fig.height = 5}
test$weights <- predict(stack, type = "response", newdata = test)
test$mu_s <- with(test, weights[ , 1] * mu_g + weights[ , 2] * mu_l)
```

Plot predictions (top) and weights (bottom):
```{r fact6, fig.width = 7, fig.height = 8}
par(mfrow = c(2, 1), mar = c(5.1, 4.1, 1.1, 1.1))
plot(test$ldem, type = "l", col = "grey", ylab = "ldem")
lines(test$mu_s, type = "l", col = 4, lwd = 2)
plot(test$weights[ , 1], col = 1, ylab = "weight", type = 'l')
```

Compute MSE on test set:
```{r fact7, fig.width = 7, fig.height = 8}
mses <- test %>% group_by(doy) %>% summarise(mse_s = mean((ldem-mu_s)^2))
test <- test %>% left_join(mses)

colMeans(test[ , c("mse_g", "mse_l", "mse_s")])
```

Plot accumulated local effect of lagged MSEs on the weight:
```{r fact7a, fig.width = 7, fig.height = 5}
# NOTE: for this you need install_github("mfasiolo/mgcViz")
plot(ALE(stack, oind = 1, x = "mse_g_48", type = "response"))
plot(ALE(stack, oind = 1, x = "mse_l_48", type = "response"))
```



<!-- Grip strength modelling  -->
<!-- ======================= -->

<!-- We consider a simple data set containing data on grip strength (HG) vs age: -->
<!-- ```{r grip1, message = F} -->
<!-- library(gamlss.data) -->
<!-- data(grip) -->

<!-- plot(grip ~ age, data = grip) -->
<!-- ``` -->

<!-- We fit a standard Gaussian GAM -->
<!-- ```{r grid2, message = F} -->
<!-- library(mgcViz) -->
<!-- fit1 <- gamV(grip ~ s(age),  -->
<!--              data = grip,  -->
<!--              aViz = list(nsim = 50)) -->
<!-- ``` -->
<!-- Then we check the residuals mean of a grid of values along `age`: -->
<!-- ```{r grid2_check, message = F} -->
<!-- check1D(fit1, "age") + l_gridCheck1D()  -->
<!-- ``` -->
<!-- Now we check the residuals standard deviation along `age` -->
<!-- ```{r grid2_check_sd, message = F} -->
<!-- check1D(fit1, "age") + l_gridCheck1D( sd ) # <- notice that we are looking at stan dev -->
<!-- ``` -->
<!-- The variance is clearly increasing with `age`. We take this into account using a `gaulss` model -->
<!-- ```{r grid3, message = F} -->
<!-- fit2 <- gamV(list(grip ~ s(age), ~ s(age)), -->
<!--              data = grip,  -->
<!--              family = gaulss, -->
<!--              aViz = list(nsim = 50)) -->
<!-- ``` -->
<!-- and we repeat the check -->
<!-- ```{r grid3_check_sd_2, message = F} -->
<!-- check1D(fit2, "age") + l_gridCheck1D( sd ) -->
<!-- ``` -->
<!-- The residual check now looks ok. These are the estimated mean and log stand. dev. effects -->
<!-- ```{r grid4, message = F, fig.width = 9, fig.height = 4} -->
<!-- print(plot(fit2), pages = 1) -->
<!-- ``` -->
<!-- We looks at a residual QQ-plot -->
<!-- ```{r gridQQ, message = F, fig.width = 4, fig.height = 4} -->
<!-- qq(fit2, CI = "normal") -->
<!-- ``` -->
<!-- The residuals look skewed to the right. We can also know check whether the residual skewness (asymmetry) changes with age -->
<!-- ```{r grid5, message = F} -->
<!-- library(e1071) -->
<!-- check1D(fit2, "age") + l_gridCheck1D( skewness ) -->
<!-- ``` -->
<!-- It seems that the skewness decreases with age. It would have been difficult to see this directly from the data -->
<!-- ```{r grip_dataPlot, message = F} -->
<!-- plot(grip ~ age, data = grip) -->
<!-- ``` -->
<!-- We allow for skewness by adopting a `shash` model -->
<!-- ```{r grid6, message = F} -->
<!-- fit3 <- gamV(list(grip ~ s(age), # location -->
<!--                   ~ s(age),      # scale (variance) -->
<!--                   ~ s(age),      # skewness (asymmetry) -->
<!--                   ~ 1),          # kurtosis (tail behaviour) -->
<!--              data = grip,  -->
<!--              family = shash, -->
<!--              aViz = list(nsim = 50)) -->

<!-- check1D(fit3, "age") + l_gridCheck1D( skewness ) -->
<!-- ``` -->
<!-- The skewness seems to be better modelled now, and we achieve lower AIC: -->
<!-- ```{r grid7, message = F} -->
<!-- AIC(fit1, fit2, fit3) -->
<!-- ``` -->
<!-- The next step is to have a look at residual kurtosis (tail behaviour), this could be done by: -->
<!-- ```{r grid8, message = F, eval = FALSE} -->
<!-- check1D(fit3, "age") + l_gridCheck1D( kurtosis ) -->
<!-- ``` -->
<!-- but we leave it for next time. -->

<!-- More complex checks -->
<!-- ======================= -->

<!-- An alternative conditional residual check is provided by `l_densCheck` layer. This compares the empirical and the theoretical (model based) residuals distribution. It generates a heat-map of: -->
<!-- $$ -->
<!-- \delta(x, r) = \verb|dFun|\{\hat{p}(r|x) - \phi(r|x) \}, -->
<!-- $$ -->
<!-- where -->

<!--   - $\hat{p}(r|x)$ is an estimate of the conditional distribution of the residuals $r$; -->
<!--   - $\phi(r|x)$ is theoretical distribution (currently only $N(0, 1)$); -->
<!--   - `dFun` is a distance function. By default: `dFun <- function(emp, th) abs(sqrt(em)-sqrt(th))^(1/3)|.` -->

<!-- `l_densCheck` is useful for identifying residual anomalies, varying variance, skewness etc. Usage: -->

<!-- <!-- For example if we reconsider the first GAM model above, that is: --> -->
<!-- <!-- ```{r grid9, message = F, eval = FALSE} --> -->
<!-- <!-- fit1 <- gamV(grip ~ s(age), ... --> -->
<!-- <!-- ``` --> -->
<!-- <!-- and we perform a `l_densCheck` check: --> -->
<!-- ```{r grid10, message = F, eval = FALSE} -->
<!-- check1D(fit1, "age") + l_densCheck(  ) -->
<!-- ``` -->
<!-- <!-- Here the bright yellow areas are those where the empirical density of the residuals is higher than it should be, relative to the model. In this specific plot the distribution of the residual is too skew to the right for $age > 13$, while for $age > 15$ ($age < 12$) the variance is too high (too low). --> -->

<!-- Here are some examples on how to interpret such plots: -->
<!-- ```{r grid11, message = F, echo = FALSE} -->
<!-- set.seed(523) -->
<!-- pl <- list() -->

<!-- ##### 1 Well specified -->
<!-- dat <-  rnorm(2000) -->
<!-- x <- rnorm(2000) -->
<!-- dataf <- data.frame(cbind(dat, x)) -->
<!-- names(dataf) <- c("y", "x") -->

<!-- ## Fit model -->
<!-- fit <- gam(form = y ~ x, data = dataf) # Here we are using a new optimizer -->

<!-- fit <- getViz(fit) -->

<!-- pl[[1]] <- check1D(fit, x = "x", maxpo = 200) + -->
<!--   l_densCheck(tol = -1) + l_points(shape = 19, size = 0.2) + -->
<!--   labs(title = "Well specified", y = "Residuals") + -->
<!--   theme(legend.position="none") -->

<!-- ##### 2 Varying mean -->
<!-- ##  Simulate some data form shash -->
<!-- set.seed(847) -->
<!-- n <- 1000 -->
<!-- x <- seq(-4, 4, length.out = n) -->


<!-- X <- cbind(1, x, x^2) -->
<!-- beta <- c(4, 1, 0.1) -->
<!-- mu <- X %*% beta -->

<!-- sigma =  .5 #+0.4*(x+4)*.5            # Scale -->
<!-- eps = 0 #2*sin(x)                     # Skewness -->
<!-- del = 1 #1 + 0.2*cos(3*x)             # Kurtosis -->

<!-- dat <-  mu + (del * sigma) * sinh((1/del) * asinh(qnorm(runif(n))) + (eps/del)) -->
<!-- dataf <- data.frame(cbind(dat, x)) -->
<!-- names(dataf) <- c("y", "x") -->

<!-- ## Fit model -->
<!-- fit <- gam(form = y ~ x, data = dataf) # Here we are using a new optimizer -->

<!-- fit <- getViz(fit) -->

<!-- pl[[2]] <- check1D(fit, x = dataf$x, maxpo = 200) + l_densCheck(tol = -1) + -->
<!--            l_points(shape = 19, size = 0.2) + -->
<!--            labs(title = "Varying mean or location", y = "Residuals") + -->
<!--            theme(legend.position="none") -->

<!-- ##### 3 Varying variance -->
<!-- library(MASS) -->
<!-- b <- gamV(accel~s(times,k=20,bs="ad"), data=mcycle) -->

<!-- pl[[3]] <- check1D(b, x = "times") + l_densCheck(tol = -1) + -->
<!--            l_points(shape = 19, size = 0.2) + -->
<!--            labs(title = "Varying variance", y = "Residuals", x = "x") + -->
<!--            theme(legend.position="none") -->

<!-- ##### 4 Varying skewness -->
<!-- X <- cbind(1, x, x^2) -->
<!-- beta <- c(4, 1, 0.1) -->
<!-- mu <- X %*% (beta * 0) -->

<!-- sigma =  .5 #+0.6*(x+4)*.5            # Scale -->
<!-- eps = 1*sin(x)                     # Skewness -->
<!-- del = 1 #1 + 0.2*cos(3*x)             # Kurtosis -->

<!-- dat <-  mu + (del * sigma) * sinh((1/del) * asinh(qnorm(runif(n))) + (eps/del)) -->
<!-- dataf <- data.frame(cbind(dat, x)) -->
<!-- names(dataf) <- c("y", "x") -->

<!-- fit <- gam(form = y ~ x, data = dataf) # Here we are using a new optimizer -->
<!-- fit <- getViz(fit) -->

<!-- pl[[4]] <- check1D(fit, x = dataf$x, maxpo = 200) + -->
<!--              l_densCheck(tol = -1) + l_points(shape = 19, size = 0.2) + -->
<!--            labs(title = "Varying skewness", y = "Residuals", x = "x") + -->
<!--            theme(legend.position="none") -->

<!-- ##### Final plot -->
<!-- library(gridExtra) -->
<!-- grid.arrange(grobs = lapply(pl, "[[", "ggObj"), ncol = 2) -->
<!-- ``` -->




